---
description: Analyse approfondie du code HIMYC - fonctions, doublons, UI/UX, performance et maintenabilit√©
alwaysApply: true
---

# Analyse Approfondie du Code HowIMetYourCorpus

## üéØ Objectif Principal

Lors de chaque intervention sur le code, analyser syst√©matiquement :
1. **Fonctions et responsabilit√©s** : Clart√©, coh√©sion, SRP (Single Responsibility Principle)
2. **Doublons et redondances** : Code dupliqu√©, logique r√©p√©t√©e, opportunit√©s de factorisation
3. **Interface Utilisateur (UI)** : Coh√©rence visuelle, accessibilit√©, ergonomie Qt/PySide6
4. **Exp√©rience Utilisateur (UX)** : Fluidit√©, feedback, gestion d'erreurs, parcours utilisateur
5. **Performance** : Optimisations possibles, requ√™tes DB, traitements lourds
6. **Maintenabilit√©** : Documentation, typage, modularit√©, testabilit√©

## üìã Architecture du Projet

### Structure des Onglets
L'application HIMYC comporte **7 onglets principaux** :

1. **Projet (TAB_PROJET=0)** : Configuration du projet, source, URL s√©rie, profils
2. **Corpus (TAB_CORPUS=1)** : Import, normalisation, segmentation, d√©couverte d'√©pisodes
3. **Inspecteur (TAB_INSPECTEUR=2)** : Vue d√©taill√©e √©pisode (transcript RAW/CLEAN + sous-titres)
4. **Alignement (TAB_ALIGNEMENT=3)** : Alignement transcript‚Üîsous-titres, liens
5. **Concordance (TAB_CONCORDANCE=4)** : Concordancier parall√®le multilingue, recherche KWIC
6. **Personnages (TAB_PERSONNAGES=5)** : Assignation segment/cue‚Üípersonnage
7. **Logs (TAB_LOGS=6)** : Journalisation des op√©rations

### Composants Cl√©s
- `MainWindow` : Fen√™tre principale orchestrant les onglets
- `ProjectStore` : Gestion persistance (config.toml, JSON)
- `CorpusDB` : Base de donn√©es SQLite (segments, sous-titres, alignements, KWIC)
- `JobRunner` : Ex√©cution asynchrone des t√¢ches pipeline
- Widgets d'onglets : `ProjectTabWidget`, `CorpusTabWidget`, `InspecteurEtSousTitresTabWidget`, etc.

## üîç Checklist d'Analyse Syst√©matique

### 1. Analyse des Fonctions

#### Pour Chaque Fonction/M√©thode :
- ‚úÖ **Responsabilit√© unique** : La fonction fait-elle une seule chose clairement d√©finie ?
- ‚úÖ **Nom descriptif** : Le nom refl√®te-t-il pr√©cis√©ment ce que fait la fonction ?
- ‚úÖ **Longueur raisonnable** : < 50 lignes id√©alement (< 100 max, sinon d√©couper)
- ‚úÖ **Param√®tres** : Moins de 5 param√®tres (sinon regrouper en dataclass/dict)
- ‚úÖ **Type hints** : Tous les param√®tres et retours sont-ils typ√©s ?
- ‚úÖ **Docstring** : Pr√©sente et explicite pour fonctions publiques/complexes
- ‚úÖ **D√©pendances** : La fonction d√©pend-elle de trop d'√©tat global ?

#### Exemple d'Am√©lioration :
```python
# ‚ùå AVANT : Fonction trop longue, responsabilit√©s multiples
def process_episode_data(self, ep_id: str):
    # 80 lignes m√©langeant validation, DB, normalisation, UI...
    pass

# ‚úÖ APR√àS : D√©coupage en fonctions focalis√©es
def _validate_episode_id(self, ep_id: str) -> bool:
    """Valide le format de l'ID √©pisode (S01E01)."""
    return bool(re.match(r"S\d{2}E\d{2}", ep_id))

def _fetch_episode_data(self, ep_id: str) -> EpisodeData:
    """R√©cup√®re les donn√©es de l'√©pisode depuis la DB."""
    return self._db.get_episode(ep_id)

def _normalize_and_display(self, data: EpisodeData) -> None:
    """Normalise et affiche les donn√©es dans l'UI."""
    normalized = self._normalizer.normalize(data)
    self._display_in_ui(normalized)
```

### 2. D√©tection des Doublons

#### Rechercher Activement :
- üîÑ **Code dupliqu√©** : M√™me logique dans plusieurs fichiers/fonctions
- üîÑ **Requ√™tes DB similaires** : Opportunit√©s de factoriser en m√©thodes r√©utilisables
- üîÑ **Validation r√©p√©t√©e** : Validation UI/donn√©es redondante
- üîÑ **Patterns Qt r√©currents** : Cr√©er des widgets/dialogs r√©utilisables
- üîÑ **Traitement de donn√©es** : Normalisation, parsing, transformation dupliqu√©s

#### Strat√©gies de D√©duplication :
```python
# ‚ùå AVANT : Validation dupliqu√©e dans 3 onglets
# tab_corpus.py
if not self._store:
    QMessageBox.warning(self, "Erreur", "Ouvrez un projet d'abord.")
    return

# tab_alignment.py
if not self._store:
    QMessageBox.warning(self, "Erreur", "Ouvrez un projet d'abord.")
    return

# ‚úÖ APR√àS : M√©thode centralis√©e ou d√©corateur
def require_project(method):
    """D√©corateur v√©rifiant qu'un projet est ouvert."""
    def wrapper(self, *args, **kwargs):
        if not self._store:
            QMessageBox.warning(self, "Projet requis", "Ouvrez un projet d'abord.")
            return None
        return method(self, *args, **kwargs)
    return wrapper

@require_project
def _perform_action(self):
    # Action n√©cessitant un projet ouvert
    pass
```

### 3. Analyse UI/UX

#### 3.1 Interface Utilisateur (UI)

##### Coh√©rence Visuelle :
- üìê **Espacement uniforme** : Marges, padding coh√©rents entre widgets
- üìê **Tailles de police** : Hi√©rarchie typographique claire (titres, labels, texte)
- üìê **Iconographie** : Utiliser des ic√¥nes pour actions importantes (clart√©)
- üìê **Couleurs** : Palette coh√©rente, codes couleur significatifs (erreur=rouge, succ√®s=vert)
- üìê **Alignement** : Widgets align√©s proprement (QFormLayout, QGridLayout)

##### Accessibilit√© :
- ‚ôø **Tooltips** : Tous les boutons/actions ont des tooltips explicatifs
- ‚ôø **Raccourcis clavier** : Actions fr√©quentes accessibles au clavier
- ‚ôø **Contraste** : Texte lisible sur fond (respecter ratios WCAG)
- ‚ôø **Focus** : Ordre de tabulation logique

##### Ergonomie Qt/PySide6 :
```python
# ‚úÖ Bonnes pratiques Qt
# 1. Utiliser QFormLayout pour formulaires
form_layout = QFormLayout()
form_layout.addRow("Nom du projet :", self.project_name_edit)
form_layout.addRow("Dossier racine :", self.root_dir_edit)

# 2. D√©sactiver widgets pendant traitement
self.process_btn.setEnabled(False)
self.progress_bar.setVisible(True)

# 3. Utiliser des splitters pour zones redimensionnables
splitter = QSplitter(Qt.Horizontal)
splitter.addWidget(left_panel)
splitter.addWidget(right_panel)
splitter.setSizes([300, 700])  # Proportions initiales

# 4. Sauvegarder/restaurer √©tat UI
settings = QSettings("HIMYC", "MainWindow")
settings.setValue("splitter/sizes", splitter.saveState())
# Restaurer : splitter.restoreState(settings.value("splitter/sizes"))
```

#### 3.2 Exp√©rience Utilisateur (UX)

##### Feedback Utilisateur :
- üí¨ **Actions confirm√©es** : Message succ√®s/√©chec clair apr√®s chaque action
- üí¨ **Progression** : Barre de progression + pourcentage pour t√¢ches longues
- üí¨ **√âtat de l'application** : Barre de statut indique l'√©tat courant
- üí¨ **Erreurs explicites** : Messages d'erreur compr√©hensibles avec solution sugg√©r√©e

##### Gestion d'Erreurs :
```python
# ‚ùå AVANT : Erreur g√©n√©rique
except Exception as e:
    QMessageBox.critical(self, "Erreur", str(e))

# ‚úÖ APR√àS : Erreur contextualis√©e avec solution
except FileNotFoundError as e:
    QMessageBox.critical(
        self,
        "Fichier introuvable",
        f"Le fichier {e.filename} est introuvable.\n\n"
        "V√©rifiez que le projet est correctement initialis√©.\n"
        "Essayez : Projet ‚Üí Valider pour recr√©er la structure."
    )
except ValidationError as e:
    QMessageBox.warning(
        self,
        "Validation √©chou√©e",
        f"Donn√©es invalides : {e.message}\n\n{e.details}"
    )
```

##### Parcours Utilisateur :
- üö¶ **Onboarding** : Premier lancement = assistant ou guide clair
- üö¶ **Workflow logique** : Onglets dans l'ordre du workflow (Projet ‚Üí Corpus ‚Üí Alignement ‚Üí Concordance)
- üö¶ **Actions contextuelles** : Boutons activ√©s/d√©sactiv√©s selon l'√©tat
- üö¶ **Navigation fluide** : Liens entre onglets (ex: Concordance ‚Üí Inspecteur sur √©pisode)

##### Productivit√© :
- ‚ö° **Actions par lot** : Traiter plusieurs √©l√©ments simultan√©ment
- ‚ö° **Raccourcis contextuels** : Menu clic-droit pertinent
- ‚ö° **Historique** : Retour aux √©tats pr√©c√©dents si pertinent
- ‚ö° **Filtres/recherche** : Acc√®s rapide aux donn√©es nombreuses

### 4. Performance

#### Points de Vigilance :

##### Base de Donn√©es :
```python
# ‚ùå AVANT : N+1 queries
for episode_id in episode_ids:
    segments = db.get_segments(episode_id)  # Requ√™te par √©pisode !

# ‚úÖ APR√àS : Requ√™te group√©e
segments_by_episode = db.get_segments_bulk(episode_ids)
```

##### Chargement UI :
```python
# ‚ùå AVANT : Remplissage synchrone bloquant
def refresh_table(self):
    data = self._db.get_all_episodes()  # Peut √™tre long
    for row in data:
        self.table.insertRow(...)  # Bloque l'UI

# ‚úÖ APR√àS : Chargement asynchrone avec feedback
def refresh_table(self):
    self.progress_bar.setVisible(True)
    self.worker = DataLoader(self._db)
    self.worker.data_ready.connect(self._populate_table)
    self.worker.start()

def _populate_table(self, data):
    self.table.setRowCount(0)
    for row in data:
        self.table.insertRow(...)
    self.progress_bar.setVisible(False)
```

##### Traitement de Fichiers :
- üì¶ **Streaming** : Lire gros fichiers en morceaux (pas tout en m√©moire)
- üì¶ **Cache** : Mettre en cache r√©sultats co√ªteux (ex: parsing, normalisation)
- üì¶ **Lazy loading** : Charger donn√©es seulement quand n√©cessaire

### 5. Maintenabilit√©

#### Code Propre :
```python
# ‚úÖ Type hints exhaustifs
def process_episode(
    self,
    episode_id: str,
    normalize: bool = True,
    profile: str | None = None
) -> EpisodeResult:
    """Traite un √©pisode avec normalisation optionnelle.
    
    Args:
        episode_id: ID √©pisode format S01E01
        normalize: Applique profil de normalisation
        profile: Profil custom (d√©faut: celui du projet)
        
    Returns:
        R√©sultat du traitement avec statut et segments
        
    Raises:
        ValueError: Si episode_id invalide
        DatabaseError: Si √©chec d'enregistrement
    """
    pass
```

#### Modularit√© :
- üß© **S√©paration concerns** : UI ‚â† logique m√©tier ‚â† acc√®s donn√©es
- üß© **D√©pendances inject√©es** : `get_db=lambda: self._db` plut√¥t que couplage fort
- üß© **Interfaces claires** : Protocoles/ABC pour composants interchangeables

#### Testabilit√© :
```python
# ‚úÖ Fonction testable (pure, sans √©tat)
def normalize_text(text: str, profile: NormalizeProfile) -> str:
    """Normalise texte selon profil (fonction pure)."""
    return profile.apply(text)

# ‚ùå Fonction difficilement testable (d√©pendances cach√©es)
def normalize_text_bad(self, text: str) -> str:
    profile = self._store.load_profile(self._config.normalize_profile)
    db_entry = self._db.get_normalization_rules(profile.id)
    # ... m√©lange UI, DB, logique
```

## üé® Analyse Sp√©cifique des Onglets

### Onglet **Projet**
**Fonction** : Configuration initiale (dossier, source, URL, profils)

**√Ä v√©rifier** :
- ‚úÖ Validation formulaire compl√®te avant cr√©ation projet
- ‚úÖ Feedback clair si projet existe d√©j√† vs nouveau
- ‚úÖ Gestion √©l√©gante du cas "SRT only" (pas d'URL s√©rie)
- ‚úÖ Liste des profils mise √† jour dynamiquement (custom + pr√©d√©finis)

**UX critique** :
- Premier contact utilisateur ‚Üí messages d'erreur tr√®s clairs
- Tooltips explicatifs sur chaque champ (ex: "Rate limit" = pourquoi ?)

### Onglet **Corpus**
**Fonction** : Workflow principal (d√©couverte, fetch, normalisation, segmentation)

**√Ä v√©rifier** :
- ‚úÖ Arbre √©pisodes : performance si 100+ √©pisodes ?
- ‚úÖ Boutons activ√©s/d√©sactiv√©s selon √©tat (projet ouvert, job en cours)
- ‚úÖ Annulation job = nettoyage propre (rollback DB partiel ?)
- ‚úÖ Reprise sur √©chec = cibl√©e sur √©pisodes √©chou√©s uniquement

**Performance** :
- Fetch parall√®le d'√©pisodes (rate limiting respect√©)
- Normalisation par lot (pas √©pisode par √©pisode)

### Onglet **Inspecteur**
**Fonction** : Vue d√©taill√©e √©pisode (transcript + sous-titres dans un splitter)

**√Ä v√©rifier** :
- ‚úÖ Synchronisation transcript ‚Üî sous-titres (scroll simultan√© ?)
- ‚úÖ √âdition notes √©pisode sauvegard√©e automatiquement
- ‚úÖ Performance affichage si 500+ segments
- ‚úÖ Recherche in-page (Ctrl+F) dans les segments

**UX critique** :
- Navigation fluide entre √©pisodes (combo ou fl√®ches pr√©c√©dent/suivant)
- Indicateur visuel si modifications non sauvegard√©es

### Onglet **Alignement**
**Fonction** : Aligner transcript ‚Üî sous-titres, g√©rer liens

**√Ä v√©rifier** :
- ‚úÖ Algorithme alignement = param√©trable ? (seuils, m√©thode)
- ‚úÖ Visualisation liens (table, graphe ?)
- ‚úÖ √âdition manuelle liens (ajouter/supprimer)
- ‚úÖ Export r√©sultats alignement (formats multiples)

**Performance** :
- Alignement lourd = asynchrone avec feedback progression

### Onglet **Concordance**
**Fonction** : Recherche KWIC parall√®le multilingue

**√Ä v√©rifier** :
- ‚úÖ Recherche performante (index DB ? regex vs LIKE)
- ‚úÖ Filtres avanc√©s (√©pisode, langue, personnage, regex)
- ‚úÖ Export r√©sultats (CSV, TXT, clipboard)
- ‚úÖ Lien vers Inspecteur sur clic r√©sultat

**UX critique** :
- Historique recherches r√©centes
- Compteur r√©sultats en temps r√©el
- Surlignage des correspondances dans les segments

### Onglet **Personnages**
**Fonction** : Assigner segments/cues √† des personnages

**√Ä v√©rifier** :
- ‚úÖ Cr√©ation/√©dition personnages intuitive
- ‚úÖ Assignation manuelle vs automatique (patterns ?)
- ‚úÖ Propagation assignations entre langues (apr√®s alignement)
- ‚úÖ Statistiques par personnage (nb interventions, r√©partition √©pisodes)

**Performance** :
- Assignation en masse = asynchrone si > 100 segments

### Onglet **Logs**
**Fonction** : Journal des op√©rations

**√Ä v√©rifier** :
- ‚úÖ Rotation logs (limite taille fichier)
- ‚úÖ Filtrage niveau (DEBUG, INFO, ERROR)
- ‚úÖ Recherche texte dans logs
- ‚úÖ Ouverture fichier log externe (√©diteur syst√®me)

## üöÄ M√©thodologie d'Intervention

### √Ä Chaque Modification de Code :

1. **Lire le contexte** : Quel onglet/fonction ? Quel workflow ?
2. **Identifier doublons** : Ce code existe-t-il ailleurs ? Peut-on factoriser ?
3. **V√©rifier UI/UX** :
   - Message d'erreur clair ?
   - Boutons activ√©s/d√©sactiv√©s logiquement ?
   - Feedback progression si t√¢che longue ?
4. **Optimiser performance** :
   - Requ√™te DB optimale ?
   - Traitement asynchrone si > 1s ?
5. **Documenter** : Ajouter docstring si fonction complexe/publique
6. **Expliquer** : Commenter **pourquoi** (pas quoi) pour logique non √©vidente

### Format des Explications

Lors d'une modification, **toujours expliquer** :

```
## üîß Modification : [Titre court]

### üìç Localisation
Fichier : `chemin/vers/fichier.py`
Fonction/Classe : `nom_fonction` / `NomClasse`
Onglet concern√© : [Projet / Corpus / Inspecteur / Alignement / Concordance / Personnages / Logs]

### ‚ùì Probl√®me Identifi√©
[Description concise du probl√®me : doublon, UX, performance, bug]

### ‚úÖ Solution Apport√©e
[Explication de la solution, choix de design]

### üéØ Impact UX/Performance
[En quoi cela am√©liore l'exp√©rience utilisateur ou la performance]

### üìä Tests Sugg√©r√©s
[Comment v√©rifier que la modification fonctionne]
```

## üìù Exemple d'Analyse Compl√®te

### Cas R√©el : M√©thode `_on_job_finished` (ui_mainwindow.py)

#### Analyse Actuelle :
- ‚úÖ **Fonction** : Traite fin de job, affiche r√©sum√©, rafra√Æchit UI
- ‚ö†Ô∏è **Longueur** : ~40 lignes ‚Üí acceptable mais dense
- ‚úÖ **Feedback** : Bon (r√©sum√© succ√®s/√©checs, liste √©pisodes √©chou√©s)
- ‚ùå **Doublon potentiel** : Logique extraction `episode_id` depuis message (regex) pourrait √™tre factoris√©e
- ‚ö†Ô∏è **Performance** : Refresh tous les onglets ‚Üí peut √™tre optimis√© (seulement onglets visibles ?)

#### Am√©lioration Sugg√©r√©e :
```python
# Factoriser extraction episode_id
def _extract_episode_id_from_message(self, message: str) -> str | None:
    """Extrait l'ID √©pisode (S01E01) depuis un message d'erreur."""
    match = re.search(r"S\d+E\d+", message, re.IGNORECASE)
    return match.group(0).upper() if match else None

# Refresh cibl√©
def _refresh_visible_tabs_only(self):
    """Rafra√Æchit seulement l'onglet actuellement visible."""
    current = self.tabs.currentIndex()
    if current == TAB_CORPUS:
        self._refresh_episodes_from_store()
    elif current == TAB_INSPECTEUR:
        self._refresh_inspecteur_episodes()
    # ...
```

## üéì Principes Directeurs

### Toujours Viser :
1. ‚ö° **Efficacit√©** : Minimiser requ√™tes DB, traitements asynchrones, cache intelligent
2. üöÄ **Performance** : UI r√©active, feedback imm√©diat, pas de blocage
3. üîß **Maintenabilit√©** : Code lisible, document√©, modulaire, test√©
4. üòä **Ergonomie** : UX intuitive, messages clairs, parcours fluide

### Ne Jamais :
- ‚ùå Dupliquer code (factoriser syst√©matiquement)
- ‚ùå Bloquer UI (async/threading pour t√¢ches > 500ms)
- ‚ùå Laisser erreurs g√©n√©riques (contextualiser, proposer solution)
- ‚ùå Ignorer l'accessibilit√© (tooltips, raccourcis clavier)

---

**Note** : Cette r√®gle s'applique √† **tous** les fichiers du projet HIMYC. Chaque intervention doit respecter cette m√©thodologie d'analyse approfondie.
